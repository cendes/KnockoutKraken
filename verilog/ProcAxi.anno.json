[
  {
    "class":"firrtl.transforms.CombinationalPath",
    "sink":"~ProcAxiWrap|ProcAxiWrap>io_axiLite_bresp",
    "sources":[
      "~ProcAxiWrap|ProcAxiWrap>io_axiLite_awvalid",
      "~ProcAxiWrap|ProcAxiWrap>io_axiLite_wvalid",
      "~ProcAxiWrap|ProcAxiWrap>io_axiLite_awaddr"
    ]
  },
  {
    "class":"logger.LogLevelAnnotation",
    "globalLogLevel":{
      
    }
  },
  {
    "class":"firrtl.options.TargetDirAnnotation",
    "directory":"verilog"
  },
  {
    "class":"firrtl.stage.phases.DriverCompatibility$TopNameAnnotation",
    "topName":"ProcAxi"
  },
  {
    "class":"firrtl.stage.phases.DriverCompatibility$EmitOneFilePerModuleAnnotation$"
  },
  {
    "class":"firrtl.EmitAllModulesAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"ProcAxiWrap.MultAdd_3input",
    "name":"MultAdd_3input.v",
    "text":"\n  // This module describes a Multiplier,3 input adder (a*b + c + p(feedback))\n  // This can be packed into 1 DSP block (Ultrascale architecture)\n  // Make sure the widths are less than what is supported by the architecture\n module MultAdd_3input #(\n  parameter AWIDTH = 16,  // Width of multiplier's 1st input\n  parameter BWIDTH = 16,  // Width of multiplier's 2nd input\n  parameter CWIDTH = 32,  // Width of Adder input\n  parameter PWIDTH = 33   // Output Width\n ) (\n  input clk, // Clock\n  input rst, // Reset\n  input en, // Reg enable\n  input signed [AWIDTH-1:0] a, // Multiplier input\n  input signed [BWIDTH-1:0] b, // Mutiplier input\n  input signed [CWIDTH-1:0] c, // Adder input\n output signed [PWIDTH-1:0] p// Result\n );\n\n  wire signed [AWIDTH-1:0] a_r; // Multiplier input\n  wire signed [BWIDTH-1:0] b_r; // Mutiplier input\n  wire signed [CWIDTH-1:0] c_r; // Adder input\n  wire signed [PWIDTH-1:0] p_r; // Result\n\n  assign a_r = a;\n  assign b_r = b;\n  assign c_r = c;\n  assign p_r = a_r * b_r + c_r;\n  assign p = p_r;\n endmodule\n  "
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"ProcAxiWrap.BRAMTDP_1",
    "name":"BRAMTDP.v",
    "text":"\n //  Xilinx True Dual Port RAM Byte Write, Write First Single Clock RAM\n //  This code implements a parameterizable true dual port memory (both ports can read and write).\n //  The behavior of this RAM is when data is written, the new memory contents at the write\n //  address are presented on the output port.\n\n module BRAMTDP #(\n   parameter NB_COL = 4,                           // Specify number of columns (number of bytes)\n   parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)\n   parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)\n   parameter RAM_PERFORMANCE = \"HIGH_PERFORMANCE\", // Select \"HIGH_PERFORMANCE\" or \"LOW_LATENCY\"\n   parameter INIT_FILE = \"\"                        // Specify name/location of RAM initialization file if using one (leave blank if not)\n ) (\n   input clk,                             // Clock\n   input rst,                             // output reset (does not affect memory contents)\n   input [clogb2(RAM_DEPTH-1)-1:0] addra, // Port A address bus, width determined from RAM_DEPTH\n   input [clogb2(RAM_DEPTH-1)-1:0] addrb, // Port B address bus, width determined from RAM_DEPTH\n   input [(NB_COL*COL_WIDTH)-1:0] dina,   // Port A RAM input data\n   input [(NB_COL*COL_WIDTH)-1:0] dinb,   // Port B RAM input data\n   input [NB_COL-1:0] wea,                // Port A write enable\n   input [NB_COL-1:0] web,                // Port B write enable\n   input ena,                             // Port A RAM Enable, for additional power savings, disable BRAM when not in use\n   input enb,                             // Port B RAM Enable, for additional power savings, disable BRAM when not in use\n   input regcea,                          // Port A output register enable\n   input regceb,                          // Port B output register enable\n   output [(NB_COL*COL_WIDTH)-1:0] douta, // Port A RAM output data\n   output [(NB_COL*COL_WIDTH)-1:0] doutb  // Port B RAM output data\n );\n\n   reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];\n   reg [(NB_COL*COL_WIDTH)-1:0] ram_data_a = {(NB_COL*COL_WIDTH){1'b0}};\n   reg [(NB_COL*COL_WIDTH)-1:0] ram_data_b = {(NB_COL*COL_WIDTH){1'b0}};\n\n   // The following code either initializes the memory values to a specified file or to all zeros to match hardware\n   generate\n     if (INIT_FILE != \"\") begin: use_init_file\n       initial\n         $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);\n     end else begin: init_bram_to_zero\n       integer ram_index;\n       initial\n         for (ram_index = 0; ram_index < RAM_DEPTH; ram_index = ram_index + 1)\n           BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};\n     end\n   endgenerate\n\n   generate\n   genvar i;\n      for (i = 0; i < NB_COL; i = i+1) begin: byte_write\n        always @(posedge clk)\n          if (ena)\n            if (wea[i]) begin\n              BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n              ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end else begin\n              ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end\n\n        always @(posedge clk)\n          if (enb)\n            if (web[i]) begin\n              BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n              ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end else begin\n              ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end\n      end\n   endgenerate\n\n   //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)\n   generate\n     if (RAM_PERFORMANCE == \"LOW_LATENCY\") begin: no_output_register\n\n       // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing\n        assign douta = ram_data_a;\n        assign doutb = ram_data_b;\n\n     end else begin: output_register\n\n       // The following is a 2 clock cycle read latency with improve clock-to-out timing\n\n       reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};\n       reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};\n\n       always @(posedge clk)\n         if (rst)\n           douta_reg <= {(NB_COL*COL_WIDTH){1'b0}};\n         else if (regcea)\n           douta_reg <= ram_data_a;\n\n       always @(posedge clk)\n         if (rst)\n           doutb_reg <= {(NB_COL*COL_WIDTH){1'b0}};\n         else if (regceb)\n           doutb_reg <= ram_data_b;\n\n       assign douta = douta_reg;\n       assign doutb = doutb_reg;\n\n     end\n   endgenerate\n\n   //  The following function calculates the address width based on specified RAM depth\n   function integer clogb2;\n     input integer depth;\n       for (clogb2=0; depth>0; clogb2=clogb2+1)\n         depth = depth >> 1;\n   endfunction\n\n endmodule\n\n // The following is an instantiation template for xilinx_true_dual_port_write_first_byte_write_1_clock_ram\n /*\n   //  Xilinx True Dual Port RAM Byte Write Write-First Single Clock RAM\n   BRAMTDP #(\n     .NB_COL(4),                           // Specify number of columns (number of bytes)\n     .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)\n     .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)\n     .RAM_PERFORMANCE(\"HIGH_PERFORMANCE\"), // Select \"HIGH_PERFORMANCE\" or \"LOW_LATENCY\"\n     .INIT_FILE(\"\")                        // Specify name/location of RAM initialization file if using one (leave blank if not)\n   ) your_instance_name (\n     .clk(clk),       // clock\n     .rst(rst),       // output reset (does not affect memory contents)\n     .addra(addra),   // Port A address bus, width determined from RAM_DEPTH\n     .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH\n     .dina(dina),     // Port A RAM input data, width determined from NB_COL*COL_WIDTH\n     .dinb(dinb),     // Port B RAM input data, width determined from NB_COL*COL_WIDTH\n     .wea(wea),       // Port A write enable, width determined from NB_COL\n     .web(web),       // Port B write enable, width determined from NB_COL\n     .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use\n     .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use\n     .regcea(regcea), // Port A output register enable\n     .regceb(regceb), // Port B output register enable\n     .douta(douta),   // Port A RAM output data, width determined from NB_COL*COL_WIDTH\n     .doutb(doutb)    // Port B RAM output data, width determined from NB_COL*COL_WIDTH\n   );\n */\n  "
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"ProcAxiWrap.BRAMTDP",
    "name":"BRAMTDP.v",
    "text":"\n //  Xilinx True Dual Port RAM Byte Write, Write First Single Clock RAM\n //  This code implements a parameterizable true dual port memory (both ports can read and write).\n //  The behavior of this RAM is when data is written, the new memory contents at the write\n //  address are presented on the output port.\n\n module BRAMTDP #(\n   parameter NB_COL = 4,                           // Specify number of columns (number of bytes)\n   parameter COL_WIDTH = 9,                        // Specify column width (byte width, typically 8 or 9)\n   parameter RAM_DEPTH = 1024,                     // Specify RAM depth (number of entries)\n   parameter RAM_PERFORMANCE = \"HIGH_PERFORMANCE\", // Select \"HIGH_PERFORMANCE\" or \"LOW_LATENCY\"\n   parameter INIT_FILE = \"\"                        // Specify name/location of RAM initialization file if using one (leave blank if not)\n ) (\n   input clk,                             // Clock\n   input rst,                             // output reset (does not affect memory contents)\n   input [clogb2(RAM_DEPTH-1)-1:0] addra, // Port A address bus, width determined from RAM_DEPTH\n   input [clogb2(RAM_DEPTH-1)-1:0] addrb, // Port B address bus, width determined from RAM_DEPTH\n   input [(NB_COL*COL_WIDTH)-1:0] dina,   // Port A RAM input data\n   input [(NB_COL*COL_WIDTH)-1:0] dinb,   // Port B RAM input data\n   input [NB_COL-1:0] wea,                // Port A write enable\n   input [NB_COL-1:0] web,                // Port B write enable\n   input ena,                             // Port A RAM Enable, for additional power savings, disable BRAM when not in use\n   input enb,                             // Port B RAM Enable, for additional power savings, disable BRAM when not in use\n   input regcea,                          // Port A output register enable\n   input regceb,                          // Port B output register enable\n   output [(NB_COL*COL_WIDTH)-1:0] douta, // Port A RAM output data\n   output [(NB_COL*COL_WIDTH)-1:0] doutb  // Port B RAM output data\n );\n\n   reg [(NB_COL*COL_WIDTH)-1:0] BRAM [RAM_DEPTH-1:0];\n   reg [(NB_COL*COL_WIDTH)-1:0] ram_data_a = {(NB_COL*COL_WIDTH){1'b0}};\n   reg [(NB_COL*COL_WIDTH)-1:0] ram_data_b = {(NB_COL*COL_WIDTH){1'b0}};\n\n   // The following code either initializes the memory values to a specified file or to all zeros to match hardware\n   generate\n     if (INIT_FILE != \"\") begin: use_init_file\n       initial\n         $readmemh(INIT_FILE, BRAM, 0, RAM_DEPTH-1);\n     end else begin: init_bram_to_zero\n       integer ram_index;\n       initial\n         for (ram_index = 0; ram_index < RAM_DEPTH; ram_index = ram_index + 1)\n           BRAM[ram_index] = {(NB_COL*COL_WIDTH){1'b0}};\n     end\n   endgenerate\n\n   generate\n   genvar i;\n      for (i = 0; i < NB_COL; i = i+1) begin: byte_write\n        always @(posedge clk)\n          if (ena)\n            if (wea[i]) begin\n              BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n              ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dina[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end else begin\n              ram_data_a[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= BRAM[addra][(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end\n\n        always @(posedge clk)\n          if (enb)\n            if (web[i]) begin\n              BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n              ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= dinb[(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end else begin\n              ram_data_b[(i+1)*COL_WIDTH-1:i*COL_WIDTH] <= BRAM[addrb][(i+1)*COL_WIDTH-1:i*COL_WIDTH];\n            end\n      end\n   endgenerate\n\n   //  The following code generates HIGH_PERFORMANCE (use output register) or LOW_LATENCY (no output register)\n   generate\n     if (RAM_PERFORMANCE == \"LOW_LATENCY\") begin: no_output_register\n\n       // The following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing\n        assign douta = ram_data_a;\n        assign doutb = ram_data_b;\n\n     end else begin: output_register\n\n       // The following is a 2 clock cycle read latency with improve clock-to-out timing\n\n       reg [(NB_COL*COL_WIDTH)-1:0] douta_reg = {(NB_COL*COL_WIDTH){1'b0}};\n       reg [(NB_COL*COL_WIDTH)-1:0] doutb_reg = {(NB_COL*COL_WIDTH){1'b0}};\n\n       always @(posedge clk)\n         if (rst)\n           douta_reg <= {(NB_COL*COL_WIDTH){1'b0}};\n         else if (regcea)\n           douta_reg <= ram_data_a;\n\n       always @(posedge clk)\n         if (rst)\n           doutb_reg <= {(NB_COL*COL_WIDTH){1'b0}};\n         else if (regceb)\n           doutb_reg <= ram_data_b;\n\n       assign douta = douta_reg;\n       assign doutb = doutb_reg;\n\n     end\n   endgenerate\n\n   //  The following function calculates the address width based on specified RAM depth\n   function integer clogb2;\n     input integer depth;\n       for (clogb2=0; depth>0; clogb2=clogb2+1)\n         depth = depth >> 1;\n   endfunction\n\n endmodule\n\n // The following is an instantiation template for xilinx_true_dual_port_write_first_byte_write_1_clock_ram\n /*\n   //  Xilinx True Dual Port RAM Byte Write Write-First Single Clock RAM\n   BRAMTDP #(\n     .NB_COL(4),                           // Specify number of columns (number of bytes)\n     .COL_WIDTH(9),                        // Specify column width (byte width, typically 8 or 9)\n     .RAM_DEPTH(1024),                     // Specify RAM depth (number of entries)\n     .RAM_PERFORMANCE(\"HIGH_PERFORMANCE\"), // Select \"HIGH_PERFORMANCE\" or \"LOW_LATENCY\"\n     .INIT_FILE(\"\")                        // Specify name/location of RAM initialization file if using one (leave blank if not)\n   ) your_instance_name (\n     .clk(clk),       // clock\n     .rst(rst),       // output reset (does not affect memory contents)\n     .addra(addra),   // Port A address bus, width determined from RAM_DEPTH\n     .addrb(addrb),   // Port B address bus, width determined from RAM_DEPTH\n     .dina(dina),     // Port A RAM input data, width determined from NB_COL*COL_WIDTH\n     .dinb(dinb),     // Port B RAM input data, width determined from NB_COL*COL_WIDTH\n     .wea(wea),       // Port A write enable, width determined from NB_COL\n     .web(web),       // Port B write enable, width determined from NB_COL\n     .ena(ena),       // Port A RAM Enable, for additional power savings, disable port when not in use\n     .enb(enb),       // Port B RAM Enable, for additional power savings, disable port when not in use\n     .regcea(regcea), // Port A output register enable\n     .regceb(regceb), // Port B output register enable\n     .douta(douta),   // Port A RAM output data, width determined from NB_COL*COL_WIDTH\n     .doutb(doutb)    // Port B RAM output data, width determined from NB_COL*COL_WIDTH\n   );\n */\n  "
  },
  {
    "class":"firrtl.options.OutputAnnotationFileAnnotation",
    "file":"ProcAxi"
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"verilog"
  }
]